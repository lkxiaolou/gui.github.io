<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>java集合总结 | Wen Er Rd. NO. 48</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">java集合总结</h1><a id="logo" href="/.">Wen Er Rd. NO. 48</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Accueil</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">java集合总结</h1><div class="post-meta">Mar 31, 2018</div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在PHP中，集合是很简单的，就一个Array，既可以做数组，又可以做map，对比JAVA常用的List，Map，Set来说只有Set是在PHP中需要封装的,本文就Java中常用的几个集合类来做一个总结。</p>
<h1 id="常用的集合类介绍"><a href="#常用的集合类介绍" class="headerlink" title="常用的集合类介绍"></a>常用的集合类介绍</h1><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List的特点是有序，元素可重复</p>
<h6 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h6><p>ArrayList的实现其实是对一个数组的封装，实现了一个动态的数组，它的构造器有三种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ArrayList arrayList = new ArrayList();</div><div class="line">ArrayList arrayList1 = new ArrayList(5000);</div><div class="line">ArrayList arrayList2 = new ArrayList(linkedList);</div></pre></td></tr></table></figure>
<p>如果不指定初始大小，ArrayList默认大小是10，如果添加的元素超过10，则ArrayList会扩容。扩容的源代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Increases the capacity to ensure that it can hold at least the</div><div class="line">     * number of elements specified by the minimum capacity argument.</div><div class="line">     *</div><div class="line">     * @param minCapacity the desired minimum capacity</div><div class="line">     */</div><div class="line">    private void grow(int minCapacity) &#123;</div><div class="line">        // overflow-conscious code</div><div class="line">        int oldCapacity = elementData.length;</div><div class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</div><div class="line">        if (newCapacity - minCapacity &lt; 0)</div><div class="line">            newCapacity = minCapacity;</div><div class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</div><div class="line">            newCapacity = hugeCapacity(minCapacity);</div><div class="line">        // minCapacity is usually close to size, so this is a win:</div><div class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看出，扩容最少是目前容量的1.5倍，如果我们需要一个5000的ArrayList，初始化的时候不指定大小，使用默认容量10，那么一个一个地往里面添加元素，它将会扩容N次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">10 * 1.5 ^ N = 5000</div></pre></td></tr></table></figure>
<p>算出来N至少为16才能完成任务，也就是执行了16次copy动作，这是非常耗时的，所以建议是在知道大小时多申请一些容量，这样就不会频繁的扩容。</p>
<p>从ArrayList的实现也能看出ArrayList适合查询，不适合频繁执行添加删除元素的操作。</p>
<h6 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h6><p>Vector与ArrayList的实现方式基本一致，只是它很多方法用了synchronized来修饰，也就是线程安全的，一个时间只有一个线程可以修改，其他细节与ArrayList类似。</p>
<h6 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h6><p>Stack是基于Vector实现的一个集合，它的特点是先入后出，与Vector一样也是线程安全的。</p>
<h6 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h6><p>LinkedList的实现可以看做是一个链表，节点之间是通过指针来连接的，所以LinkedList与ArrayList互补，适合频繁地删除添加元素，而不适合查找。<br>LinkedList的初始化如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">LinkedList linkedList = new LinkedList();</div><div class="line">LinkedList linkedList1 = new LinkedList(arrayList);</div></pre></td></tr></table></figure>
<p>只有两种初始化方式，不需要指定大小。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map的特点是存储键值对</p>
<h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h6><p>HashMap采用的是将“键”的HashCode对应的存储区域存储上键和值，本质上是一个数组，只不过可以通过“键”计算出应该存在数组的哪个位置，它的key，value可以为null，无序。<br>看一下它的几个构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public HashMap(int initialCapacity, float loadFactor);</div><div class="line">public HashMap(int initialCapacity);</div><div class="line">public HashMap();</div><div class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m);</div></pre></td></tr></table></figure>
<p>看出来HashMap是有大小的，也是有一个扩容的过程。网上看到一个概括put的过程直接引用过来：</p>
<blockquote>
<ol>
<li>对key的hashCode()做hash，然后再计算index;</li>
<li>如果没碰撞直接放到bucket里；</li>
<li>如果碰撞了，以链表的形式存在buckets后；</li>
<li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li>
<li>如果节点已经存在就替换old value(保证key的唯一性)</li>
<li>如果bucket满了(超过load factor*current capacity)，就要resize。</li>
</ol>
</blockquote>
<h6 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h6><p>与HashMap类似，但是是线程安全的，键和值都不能是null，他们使用的hashCode也是不一样的，HashTable直接使用HashCode，而HahMap会在HashCode上再做一次Hash，且他们的扩容方式也不尽相同，HashTable中hash数组默认大小是11，增加的方式是old*2+1，HashMap中hash数组的默认大小是16，而且一定是2的指数</p>
<h6 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h6><p>LinkedHashMap与HashMap基本相同，只是在定义节点时增加了前后指针，这也就意味着遍历时能保证顺序，其他与HashMap无异。</p>
<h6 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h6><p>TreeMap实际上是一个红黑树的实现，与HashMap使用HashCode实现不一样，它的查找效率没有HashMap那么高效，但是也达到了O(logn)，它的元素是有序的且不能为null。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set的特点是不能存储相同的元素</p>
<h6 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h6><p>HashSet的实现是对HashMap的封装，只不过是将需要add进set的元素当成是HashMap的key，这样实现了set的不重复。</p>
<h6 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h6><p>底层采用了LinkedHashMap来实现，也是在HashSet的基础上增加了有序，读LinkedHashSet源代码没有发现和LinkedHashMap有关？仔细看，所有的LikedHashSet都是调用了HashSet的这个构造方法来初始化的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123;</div><div class="line">    map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>藏的够深，原来HaSet中有一个专门为LinkedHashMap提供的构造方法。</p>
<h6 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h6><p>TreeSet是基于TreeMap实现的，也是一个红黑树，也是有序的且不依赖Hash实现的一种Set,同理也是将要加入到set中的元素当做键插入到TreeMap中去。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>Java的集合类丰富多彩，在选择和使用时需谨慎思考</li>
<li>编写多线程程序需要注意线程安全问题，Vector、Stck和HashTable是线程安全的，其他集合都是线上不安全的。</li>
<li>Java集合涵盖了很多数据结构的知识，如红黑树就是可以展开的一个知识点</li>
<li>另外还有其他不常用的如Queue等集合在这里没有做介绍</li>
</ul>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/06/06/jackson的一个踩坑小记/">jackson的一个踩坑小记</a><a class="next" href="/2018/03/27/Spring学习笔记之bean的装配/">Spring学习笔记之bean的装配</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Catégories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Récent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/jackson的一个踩坑小记/">jackson的一个踩坑小记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/31/java集合总结/">java集合总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/Spring学习笔记之bean的装配/">Spring学习笔记之bean的装配</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/02/biz-lock/">高并发下原子操作与主从延迟下的锁的思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/19/ZooKeeper入门笔记/">ZooKeeper入门笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/23/kill-your-process/">如何正确杀死你的进程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/13/使用inotify和epoll实现tail命令/">使用inotify和epoll实现tail命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/08/redis存储分析/">redis存储分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/26/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> À suivre</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Wen Er Rd. NO. 48.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>