<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>redis存储分析 | Wen Er Rd. NO. 48</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">redis存储分析</h1><a id="logo" href="/.">Wen Er Rd. NO. 48</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">redis存储分析</h1><div class="post-meta">Dec 8, 2016</div><div class="post-content"><h2 id="一、内存"><a href="#一、内存" class="headerlink" title="一、内存"></a>一、内存</h2><h3 id="1、几个关键的数据结构"><a href="#1、几个关键的数据结构" class="headerlink" title="1、几个关键的数据结构"></a>1、几个关键的数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct redisServer &#123;</div><div class="line">    ...</div><div class="line">    redisDb *db;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef struct redisDb &#123;</div><div class="line">    dict *dict;                 /* The keyspace for this DB */</div><div class="line">    dict *expires;              /* Timeout of keys with a timeout set */</div><div class="line">    dict *blocking_keys;</div><div class="line">    dict *ready_keys;</div><div class="line">    dict *watched_keys;</div><div class="line">    struct evictionPoolEntry *eviction_pool;</div><div class="line">    int id;</div><div class="line">    long long avg_ttl;</div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct dict &#123;</div><div class="line">    dictType *type;</div><div class="line">    void *privdata;</div><div class="line">    dictht ht[2];</div><div class="line">    long rehashidx; /* rehashing not in progress if rehashidx == -1 */</div><div class="line">    int iterators; /* number of iterators currently running */</div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef struct dictht &#123;</div><div class="line">    dictEntry **table;</div><div class="line">    unsigned long size;</div><div class="line">    unsigned long sizemask;</div><div class="line">    unsigned long used;</div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef struct dictEntry &#123;</div><div class="line">    void *key;</div><div class="line">    union &#123;</div><div class="line">        void *val;</div><div class="line">        uint64_t u64;</div><div class="line">        int64_t s64;</div><div class="line">        double d;</div><div class="line">    &#125; v;</div><div class="line">    struct dictEntry *next;</div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure>
<p><img src="http://b0.hucdn.com/party/2016/11/upload_478e6a064820f8628efc1beea28283d2_1034x355.JPG" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">dictEntry *dictFind(dict *d, const void *key)</div><div class="line">&#123;</div><div class="line">    dictEntry *he;</div><div class="line">    unsigned int h, idx, table;</div><div class="line"></div><div class="line">    if (d-&gt;ht[0].size == 0) return NULL; /* We don&apos;t have a table at all */</div><div class="line">    if (dictIsRehashing(d)) _dictRehashStep(d);// 渐进式rehash迁移数据</div><div class="line">    h = dictHashKey(d, key);</div><div class="line">    for (table = 0; table &lt;= 1; table++) &#123;</div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        while(he) &#123;</div><div class="line">            if (dictCompareKeys(d, key, he-&gt;key))</div><div class="line">                return he;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        if (!dictIsRehashing(d)) return NULL;</div><div class="line">    &#125;</div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、rehash"><a href="#2、rehash" class="headerlink" title="2、rehash"></a>2、rehash</h3><h4 id="1）rehash标志"><a href="#1）rehash标志" class="headerlink" title="1）rehash标志"></a>1）rehash标志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define dictIsRehashing(d) ((d)-&gt;rehashidx != -1)</div></pre></td></tr></table></figure>
<p>-1 表示没有rehash，&gt;=1 表示 该index后面的没有进行rehash</p>
<h4 id="2）rehash过程"><a href="#2）rehash过程" class="headerlink" title="2）rehash过程"></a>2）rehash过程</h4><p>渐进式rehash 见上述dictFind实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">/* Performs N steps of incremental rehashing. Returns 1 if there are still</div><div class="line"> * keys to move from the old to the new hash table, otherwise 0 is returned.</div><div class="line"> *</div><div class="line"> * Note that a rehashing step consists in moving a bucket (that may have more</div><div class="line"> * than one key as we use chaining) from the old to the new hash table, however</div><div class="line"> * since part of the hash table may be composed of empty spaces, it is not</div><div class="line"> * guaranteed that this function will rehash even a single bucket, since it</div><div class="line"> * will visit at max N*10 empty buckets in total, otherwise the amount of</div><div class="line"> * work it does would be unbound and the function may block for a long time. */</div><div class="line">int dictRehash(dict *d, int n) &#123;</div><div class="line">    int empty_visits = n*10; /* Max number of empty buckets to visit. */</div><div class="line">    if (!dictIsRehashing(d)) return 0;</div><div class="line"></div><div class="line">    while(n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123;</div><div class="line">        dictEntry *de, *nextde;</div><div class="line"></div><div class="line">        /* Note that rehashidx can&apos;t overflow as we are sure there are more</div><div class="line">         * elements because ht[0].used != 0 */</div><div class="line">        assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx);</div><div class="line">        while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123;</div><div class="line">            d-&gt;rehashidx++;</div><div class="line">            if (--empty_visits == 0) return 1;</div><div class="line">        &#125;</div><div class="line">        de = d-&gt;ht[0].table[d-&gt;rehashidx];</div><div class="line">        /* Move all the keys in this bucket from the old to the new hash HT */</div><div class="line">        while(de) &#123;</div><div class="line">            unsigned int h;</div><div class="line"></div><div class="line">            nextde = de-&gt;next;</div><div class="line">            /* Get the index in the new hash table */</div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;</div><div class="line">            de-&gt;next = d-&gt;ht[1].table[h];</div><div class="line">            d-&gt;ht[1].table[h] = de;</div><div class="line">            d-&gt;ht[0].used--;</div><div class="line">            d-&gt;ht[1].used++;</div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;</div><div class="line">        d-&gt;rehashidx++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Check if we already rehashed the whole table... */</div><div class="line">    if (d-&gt;ht[0].used == 0) &#123;</div><div class="line">        zfree(d-&gt;ht[0].table);</div><div class="line">        d-&gt;ht[0] = d-&gt;ht[1];</div><div class="line">        _dictReset(&amp;d-&gt;ht[1]);</div><div class="line">        d-&gt;rehashidx = -1;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* More to rehash... */</div><div class="line">    return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3）rehash条件"><a href="#3）rehash条件" class="headerlink" title="3）rehash条件"></a>3）rehash条件</h4><p>负载因子 = ht[0].used / ht[0].size<br>负载因子 &gt;= 5 说明 hash冲突已经很明显 =&gt; 扩张table<br>负载因子 &lt; 0.1 说明表太大 =&gt; 收缩</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* Using dictEnableResize() / dictDisableResize() we make possible to</div><div class="line"> * enable/disable resizing of the hash table as needed. This is very important</div><div class="line"> * for Redis, as we use copy-on-write and don&apos;t want to move too much memory</div><div class="line"> * around when there is a child performing saving operations.</div><div class="line"> *</div><div class="line"> * Note that even when dict_can_resize is set to 0, not all resizes are</div><div class="line"> * prevented: a hash table is still allowed to grow if the ratio between</div><div class="line"> * the number of elements and the buckets &gt; dict_force_resize_ratio. */</div><div class="line">static int dict_can_resize = 1;</div><div class="line">static unsigned int dict_force_resize_ratio = 5;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int htNeedsResize(dict *dict) &#123;</div><div class="line">    long long size, used;</div><div class="line"></div><div class="line">    size = dictSlots(dict);</div><div class="line">    used = dictSize(dict);</div><div class="line">    return (size &amp;&amp; used &amp;&amp; size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</div><div class="line">            (used*100/size &lt; REDIS_HT_MINFILL));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/* Expand the hash table if needed */</div><div class="line">static int _dictExpandIfNeeded(dict *d)</div><div class="line">&#123;</div><div class="line">    /* Incremental rehashing already in progress. Return. */</div><div class="line">    if (dictIsRehashing(d)) return DICT_OK;</div><div class="line"></div><div class="line">    /* If the hash table is empty expand it to the initial size. */</div><div class="line">    if (d-&gt;ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);</div><div class="line"></div><div class="line">    /* If we reached the 1:1 ratio, and we are allowed to resize the hash</div><div class="line">     * table (global setting) or we should avoid it but the ratio between</div><div class="line">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</div><div class="line">     * the number of buckets. */</div><div class="line">    if (d-&gt;ht[0].used &gt;= d-&gt;ht[0].size &amp;&amp;</div><div class="line">        (dict_can_resize ||</div><div class="line">         d-&gt;ht[0].used/d-&gt;ht[0].size &gt; dict_force_resize_ratio))</div><div class="line">    &#123;</div><div class="line">        return dictExpand(d, d-&gt;ht[0].used*2);</div><div class="line">    &#125;</div><div class="line">    return DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>used和size分别是什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">dictEntry *dictAddRaw(dict *d, void *key)</div><div class="line">&#123;</div><div class="line">    int index;</div><div class="line">    dictEntry *entry;</div><div class="line">    dictht *ht;</div><div class="line"></div><div class="line">    if (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line"></div><div class="line">    /* Get the index of the new element, or -1 if</div><div class="line">     * the element already exists. */</div><div class="line">    if ((index = _dictKeyIndex(d, key)) == -1)</div><div class="line">        return NULL;</div><div class="line"></div><div class="line">    /* Allocate the memory and store the new entry */</div><div class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];</div><div class="line">    entry = zmalloc(sizeof(*entry));</div><div class="line">    entry-&gt;next = ht-&gt;table[index];</div><div class="line">    ht-&gt;table[index] = entry;</div><div class="line">    ht-&gt;used++;</div><div class="line"></div><div class="line">    /* Set the hash entry fields. */</div><div class="line">    dictSetKey(d, entry, key);</div><div class="line">    return entry;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、过期机制"><a href="#3、过期机制" class="headerlink" title="3、过期机制"></a>3、过期机制</h3><p>单独维护 expires，见上述redisDB</p>
<p>获取key的过期时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/* Return the expire time of the specified key, or -1 if no expire</div><div class="line"> * is associated with this key (i.e. the key is non volatile) */</div><div class="line">long long getExpire(redisDb *db, robj *key) &#123;</div><div class="line">    dictEntry *de;</div><div class="line"></div><div class="line">    /* No expire? return ASAP */</div><div class="line">    if (dictSize(db-&gt;expires) == 0 ||</div><div class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == NULL) return -1;</div><div class="line"></div><div class="line">    /* The entry was found in the expire dict, this means it should also</div><div class="line">     * be present in the main dict (safety check). */</div><div class="line">    redisAssertWithInfo(NULL,key,dictFind(db-&gt;dict,key-&gt;ptr) != NULL);</div><div class="line">    return dictGetSignedIntegerVal(de);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面的函数是get命令的实现，由此可看出key过期是一种惰性删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">robj *lookupKeyRead(redisDb *db, robj *key) &#123;</div><div class="line">    robj *val;</div><div class="line"></div><div class="line">    expireIfNeeded(db,key);</div><div class="line">    val = lookupKey(db,key);</div><div class="line">    if (val == NULL)</div><div class="line">        server.stat_keyspace_misses++;</div><div class="line">    else</div><div class="line">        server.stat_keyspace_hits++;</div><div class="line">    return val;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>随机淘汰<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div></pre></td><td class="code"><pre><div class="line">/* ======================= Cron: called every 100 ms ======================== */</div><div class="line"></div><div class="line">/* Helper function for the activeExpireCycle() function.</div><div class="line"> * This function will try to expire the key that is stored in the hash table</div><div class="line"> * entry &apos;de&apos; of the &apos;expires&apos; hash table of a Redis database.</div><div class="line"> *</div><div class="line"> * If the key is found to be expired, it is removed from the database and</div><div class="line"> * 1 is returned. Otherwise no operation is performed and 0 is returned.</div><div class="line"> *</div><div class="line"> * When a key is expired, server.stat_expiredkeys is incremented.</div><div class="line"> *</div><div class="line"> * The parameter &apos;now&apos; is the current time in milliseconds as is passed</div><div class="line"> * to the function to avoid too many gettimeofday() syscalls. */</div><div class="line">int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) &#123;</div><div class="line">    long long t = dictGetSignedIntegerVal(de);</div><div class="line">    if (now &gt; t) &#123;</div><div class="line">        sds key = dictGetKey(de);</div><div class="line">        robj *keyobj = createStringObject(key,sdslen(key));</div><div class="line"></div><div class="line">        propagateExpire(db,keyobj);</div><div class="line">        dbDelete(db,keyobj);</div><div class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,</div><div class="line">            &quot;expired&quot;,keyobj,db-&gt;id);</div><div class="line">        decrRefCount(keyobj);</div><div class="line">        server.stat_expiredkeys++;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Try to expire a few timed out keys. The algorithm used is adaptive and</div><div class="line"> * will use few CPU cycles if there are few expiring keys, otherwise</div><div class="line"> * it will get more aggressive to avoid that too much memory is used by</div><div class="line"> * keys that can be removed from the keyspace.</div><div class="line"> *</div><div class="line"> * No more than REDIS_DBCRON_DBS_PER_CALL databases are tested at every</div><div class="line"> * iteration.</div><div class="line"> *</div><div class="line"> * This kind of call is used when Redis detects that timelimit_exit is</div><div class="line"> * true, so there is more work to do, and we do it more incrementally from</div><div class="line"> * the beforeSleep() function of the event loop.</div><div class="line"> *</div><div class="line"> * Expire cycle type:</div><div class="line"> *</div><div class="line"> * If type is ACTIVE_EXPIRE_CYCLE_FAST the function will try to run a</div><div class="line"> * &quot;fast&quot; expire cycle that takes no longer than EXPIRE_FAST_CYCLE_DURATION</div><div class="line"> * microseconds, and is not repeated again before the same amount of time.</div><div class="line"> *</div><div class="line"> * If type is ACTIVE_EXPIRE_CYCLE_SLOW, that normal expire cycle is</div><div class="line"> * executed, where the time limit is a percentage of the REDIS_HZ period</div><div class="line"> * as specified by the REDIS_EXPIRELOOKUPS_TIME_PERC define. */</div><div class="line"></div><div class="line">void activeExpireCycle(int type) &#123;</div><div class="line">    /* This function has some global state in order to continue the work</div><div class="line">     * incrementally across calls. */</div><div class="line">    static unsigned int current_db = 0; /* Last DB tested. */</div><div class="line">    static int timelimit_exit = 0;      /* Time limit hit in previous call? */</div><div class="line">    static long long last_fast_cycle = 0; /* When last fast cycle ran. */</div><div class="line"></div><div class="line">    int j, iteration = 0;</div><div class="line">    int dbs_per_call = REDIS_DBCRON_DBS_PER_CALL;</div><div class="line">    long long start = ustime(), timelimit;</div><div class="line"></div><div class="line">    if (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</div><div class="line">        /* Don&apos;t start a fast cycle if the previous cycle did not exited</div><div class="line">         * for time limt. Also don&apos;t repeat a fast cycle for the same period</div><div class="line">         * as the fast cycle total duration itself. */</div><div class="line">        if (!timelimit_exit) return;</div><div class="line">        if (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;</div><div class="line">        last_fast_cycle = start;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* We usually should test REDIS_DBCRON_DBS_PER_CALL per iteration, with</div><div class="line">     * two exceptions:</div><div class="line">     *</div><div class="line">     * 1) Don&apos;t test more DBs than we have.</div><div class="line">     * 2) If last time we hit the time limit, we want to scan all DBs</div><div class="line">     * in this iteration, as there is work to do in some DB and we don&apos;t want</div><div class="line">     * expired keys to use memory for too much time. */</div><div class="line">    if (dbs_per_call &gt; server.dbnum || timelimit_exit)</div><div class="line">        dbs_per_call = server.dbnum;</div><div class="line"></div><div class="line">    /* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time</div><div class="line">     * per iteration. Since this function gets called with a frequency of</div><div class="line">     * server.hz times per second, the following is the max amount of</div><div class="line">     * microseconds we can spend in this function. */</div><div class="line">    timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;</div><div class="line">    timelimit_exit = 0;</div><div class="line">    if (timelimit &lt;= 0) timelimit = 1;</div><div class="line"></div><div class="line">    if (type == ACTIVE_EXPIRE_CYCLE_FAST)</div><div class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; /* in microseconds. */</div><div class="line"></div><div class="line">    for (j = 0; j &lt; dbs_per_call; j++) &#123;</div><div class="line">        int expired;</div><div class="line">        redisDb *db = server.db+(current_db % server.dbnum);</div><div class="line"></div><div class="line">        /* Increment the DB now so we are sure if we run out of time</div><div class="line">         * in the current DB we&apos;ll restart from the next. This allows to</div><div class="line">         * distribute the time evenly across DBs. */</div><div class="line">        current_db++;</div><div class="line"></div><div class="line">        /* Continue to expire if at the end of the cycle more than 25%</div><div class="line">         * of the keys were expired. */</div><div class="line">        do &#123;</div><div class="line">            unsigned long num, slots;</div><div class="line">            long long now, ttl_sum;</div><div class="line">            int ttl_samples;</div><div class="line"></div><div class="line">            /* If there is nothing to expire try next DB ASAP. */</div><div class="line">            if ((num = dictSize(db-&gt;expires)) == 0) &#123;</div><div class="line">                db-&gt;avg_ttl = 0;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            slots = dictSlots(db-&gt;expires);</div><div class="line">            now = mstime();</div><div class="line"></div><div class="line">            /* When there are less than 1% filled slots getting random</div><div class="line">             * keys is expensive, so stop here waiting for better times...</div><div class="line">             * The dictionary will be resized asap. */</div><div class="line">            if (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</div><div class="line">                (num*100/slots &lt; 1)) break;</div><div class="line"></div><div class="line">            /* The main collection cycle. Sample random keys among keys</div><div class="line">             * with an expire set, checking for expired ones. */</div><div class="line">            expired = 0;</div><div class="line">            ttl_sum = 0;</div><div class="line">            ttl_samples = 0;</div><div class="line"></div><div class="line">            if (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</div><div class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</div><div class="line"></div><div class="line">            while (num--) &#123;</div><div class="line">                dictEntry *de;</div><div class="line">                long long ttl;</div><div class="line"></div><div class="line">                if ((de = dictGetRandomKey(db-&gt;expires)) == NULL) break;</div><div class="line">                ttl = dictGetSignedIntegerVal(de)-now;</div><div class="line">                if (activeExpireCycleTryExpire(db,de,now)) expired++;</div><div class="line">                if (ttl &lt; 0) ttl = 0;</div><div class="line">                ttl_sum += ttl;</div><div class="line">                ttl_samples++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Update the average TTL stats for this database. */</div><div class="line">            if (ttl_samples) &#123;</div><div class="line">                long long avg_ttl = ttl_sum/ttl_samples;</div><div class="line"></div><div class="line">                if (db-&gt;avg_ttl == 0) db-&gt;avg_ttl = avg_ttl;</div><div class="line">                /* Smooth the value averaging with the previous one. */</div><div class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl+avg_ttl)/2;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* We can&apos;t block forever here even if there are many keys to</div><div class="line">             * expire. So after a given amount of milliseconds return to the</div><div class="line">             * caller waiting for the other active expire cycle. */</div><div class="line">            iteration++;</div><div class="line">            if ((iteration &amp; 0xf) == 0) &#123; /* check once every 16 iterations. */</div><div class="line">                long long elapsed = ustime()-start;</div><div class="line"></div><div class="line">                latencyAddSampleIfNeeded(&quot;expire-cycle&quot;,elapsed/1000);</div><div class="line">                if (elapsed &gt; timelimit) timelimit_exit = 1;</div><div class="line">            &#125;</div><div class="line">            if (timelimit_exit) return;</div><div class="line">            /* We don&apos;t repeat the cycle if there are less than 25% of keys</div><div class="line">             * found expired in the current DB. */</div><div class="line">        &#125; while (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>也就是说每秒钟 最多淘汰10个过期的key</p>
<h2 id="二、持久化"><a href="#二、持久化" class="headerlink" title="二、持久化"></a>二、持久化</h2><p>redis服务启动的时候，会去load持久化数据，优先级是有aof则aof，没有aof就rdb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Function called at startup to load RDB or AOF file in memory. */</div><div class="line">void loadDataFromDisk(void) &#123;</div><div class="line">    long long start = ustime();</div><div class="line">    if (server.aof_state == REDIS_AOF_ON) &#123;</div><div class="line">        if (loadAppendOnlyFile(server.aof_filename) == REDIS_OK)</div><div class="line">            redisLog(REDIS_NOTICE,&quot;DB loaded from append only file: %.3f seconds&quot;,(float)(ustime()-start)/1000000);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (rdbLoad(server.rdb_filename) == REDIS_OK) &#123;</div><div class="line">            redisLog(REDIS_NOTICE,&quot;DB loaded from disk: %.3f seconds&quot;,</div><div class="line">                (float)(ustime()-start)/1000000);</div><div class="line">        &#125; else if (errno != ENOENT) &#123;</div><div class="line">            redisLog(REDIS_WARNING,&quot;Fatal error loading the DB: %s. Exiting.&quot;,strerror(errno));</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1、aof"><a href="#1、aof" class="headerlink" title="1、aof"></a>1、aof</h3><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><p>以redis协议的格式存储每一条写命令<br>协议类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">命令：SET HENRY  HENRYFAN</div><div class="line">协议：</div><div class="line">*3\r\n</div><div class="line">$3\r\n</div><div class="line">SET\r\n</div><div class="line">$5\r\n</div><div class="line">HENRY\r\n</div><div class="line">$8\r\n</div><div class="line">HENRYFAN\r\n</div></pre></td></tr></table></figure></p>
<h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>server启动时aof加载会不处理客户端的请求（不是阻塞，返回错误）<br>加载时，建立一个fake客户端，循环执行aof中的命令（见aof.c/loadAppendOnlyFile）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line">/* Replay the append log file. On success REDIS_OK is returned. On non fatal</div><div class="line"> * error (the append only file is zero-length) REDIS_ERR is returned. On</div><div class="line"> * fatal error an error message is logged and the program exists. */</div><div class="line">int loadAppendOnlyFile(char *filename) &#123;</div><div class="line">    struct redisClient *fakeClient;</div><div class="line">    FILE *fp = fopen(filename,&quot;r&quot;);</div><div class="line">    struct redis_stat sb;</div><div class="line">    int old_aof_state = server.aof_state;</div><div class="line">    long loops = 0;</div><div class="line">    off_t valid_up_to = 0; /* Offset of the latest well-formed command loaded. */</div><div class="line"></div><div class="line">    if (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != -1 &amp;&amp; sb.st_size == 0) &#123;</div><div class="line">        server.aof_current_size = 0;</div><div class="line">        fclose(fp);</div><div class="line">        return REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (fp == NULL) &#123;</div><div class="line">        redisLog(REDIS_WARNING,&quot;Fatal error: can&apos;t open the append log file for reading: %s&quot;,strerror(errno));</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Temporarily disable AOF, to prevent EXEC from feeding a MULTI</div><div class="line">     * to the same file we&apos;re about to read. */</div><div class="line">    server.aof_state = REDIS_AOF_OFF;</div><div class="line"></div><div class="line">    fakeClient = createFakeClient();</div><div class="line">    startLoading(fp);</div><div class="line"></div><div class="line">    while(1) &#123;</div><div class="line">        int argc, j;</div><div class="line">        unsigned long len;</div><div class="line">        robj **argv;</div><div class="line">        char buf[128];</div><div class="line">        sds argsds;</div><div class="line">        struct redisCommand *cmd;</div><div class="line"></div><div class="line">        /* Serve the clients from time to time */</div><div class="line">        if (!(loops++ % 1000)) &#123;</div><div class="line">            loadingProgress(ftello(fp));</div><div class="line">            processEventsWhileBlocked();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (fgets(buf,sizeof(buf),fp) == NULL) &#123;</div><div class="line">            if (feof(fp))</div><div class="line">                break;</div><div class="line">            else</div><div class="line">                goto readerr;</div><div class="line">        &#125;</div><div class="line">        if (buf[0] != &apos;*&apos;) goto fmterr;</div><div class="line">        if (buf[1] == &apos;\0&apos;) goto readerr;</div><div class="line">        argc = atoi(buf+1);</div><div class="line">        if (argc &lt; 1) goto fmterr;</div><div class="line"></div><div class="line">        argv = zmalloc(sizeof(robj*)*argc);</div><div class="line">        fakeClient-&gt;argc = argc;</div><div class="line">        fakeClient-&gt;argv = argv;</div><div class="line"></div><div class="line">        for (j = 0; j &lt; argc; j++) &#123;</div><div class="line">            if (fgets(buf,sizeof(buf),fp) == NULL) &#123;</div><div class="line">                fakeClient-&gt;argc = j; /* Free up to j-1. */</div><div class="line">                freeFakeClientArgv(fakeClient);</div><div class="line">                goto readerr;</div><div class="line">            &#125;</div><div class="line">            if (buf[0] != &apos;$&apos;) goto fmterr;</div><div class="line">            len = strtol(buf+1,NULL,10);</div><div class="line">            argsds = sdsnewlen(NULL,len);</div><div class="line">            if (len &amp;&amp; fread(argsds,len,1,fp) == 0) &#123;</div><div class="line">                sdsfree(argsds);</div><div class="line">                fakeClient-&gt;argc = j; /* Free up to j-1. */</div><div class="line">                freeFakeClientArgv(fakeClient);</div><div class="line">                goto readerr;</div><div class="line">            &#125;</div><div class="line">            argv[j] = createObject(REDIS_STRING,argsds);</div><div class="line">            if (fread(buf,2,1,fp) == 0) &#123;</div><div class="line">                fakeClient-&gt;argc = j+1; /* Free up to j. */</div><div class="line">                freeFakeClientArgv(fakeClient);</div><div class="line">                goto readerr; /* discard CRLF */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Command lookup */</div><div class="line">        cmd = lookupCommand(argv[0]-&gt;ptr);</div><div class="line">        if (!cmd) &#123;</div><div class="line">            redisLog(REDIS_WARNING,&quot;Unknown command &apos;%s&apos; reading the append only file&quot;, (char*)argv[0]-&gt;ptr);</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Run the command in the context of a fake client */</div><div class="line">        cmd-&gt;proc(fakeClient);</div><div class="line"></div><div class="line">        /* The fake client should not have a reply */</div><div class="line">        redisAssert(fakeClient-&gt;bufpos == 0 &amp;&amp; listLength(fakeClient-&gt;reply) == 0);</div><div class="line">        /* The fake client should never get blocked */</div><div class="line">        redisAssert((fakeClient-&gt;flags &amp; REDIS_BLOCKED) == 0);</div><div class="line"></div><div class="line">        /* Clean up. Command code may have changed argv/argc so we use the</div><div class="line">         * argv/argc of the client instead of the local variables. */</div><div class="line">        freeFakeClientArgv(fakeClient);</div><div class="line">        if (server.aof_load_truncated) valid_up_to = ftello(fp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* This point can only be reached when EOF is reached without errors.</div><div class="line">     * If the client is in the middle of a MULTI/EXEC, log error and quit. */</div><div class="line">    if (fakeClient-&gt;flags &amp; REDIS_MULTI) goto uxeof;</div><div class="line"></div><div class="line">loaded_ok: /* DB loaded, cleanup and return REDIS_OK to the caller. */</div><div class="line">    fclose(fp);</div><div class="line">    freeFakeClient(fakeClient);</div><div class="line">    server.aof_state = old_aof_state;</div><div class="line">    stopLoading();</div><div class="line">    aofUpdateCurrentSize();</div><div class="line">    server.aof_rewrite_base_size = server.aof_current_size;</div><div class="line">    return REDIS_OK;</div><div class="line"></div><div class="line">readerr: /* Read error. If feof(fp) is true, fall through to unexpected EOF. */</div><div class="line">    if (!feof(fp)) &#123;</div><div class="line">        redisLog(REDIS_WARNING,&quot;Unrecoverable error reading the append only file: %s&quot;, strerror(errno));</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">uxeof: /* Unexpected AOF end of file. */</div><div class="line">    if (server.aof_load_truncated) &#123;</div><div class="line">        redisLog(REDIS_WARNING,&quot;!!! Warning: short read while loading the AOF file !!!&quot;);</div><div class="line">        redisLog(REDIS_WARNING,&quot;!!! Truncating the AOF at offset %llu !!!&quot;,</div><div class="line">            (unsigned long long) valid_up_to);</div><div class="line">        if (valid_up_to == -1 || truncate(filename,valid_up_to) == -1) &#123;</div><div class="line">            if (valid_up_to == -1) &#123;</div><div class="line">                redisLog(REDIS_WARNING,&quot;Last valid command offset is invalid&quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">                redisLog(REDIS_WARNING,&quot;Error truncating the AOF file: %s&quot;,</div><div class="line">                    strerror(errno));</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            /* Make sure the AOF file descriptor points to the end of the</div><div class="line">             * file after the truncate call. */</div><div class="line">            if (server.aof_fd != -1 &amp;&amp; lseek(server.aof_fd,0,SEEK_END) == -1) &#123;</div><div class="line">                redisLog(REDIS_WARNING,&quot;Can&apos;t seek the end of the AOF file: %s&quot;,</div><div class="line">                    strerror(errno));</div><div class="line">            &#125; else &#123;</div><div class="line">                redisLog(REDIS_WARNING,</div><div class="line">                    &quot;AOF loaded anyway because aof-load-truncated is enabled&quot;);</div><div class="line">                goto loaded_ok;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    redisLog(REDIS_WARNING,&quot;Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;. 2) Alternatively you can set the &apos;aof-load-truncated&apos; configuration option to yes and restart the server.&quot;);</div><div class="line">    exit(1);</div><div class="line"></div><div class="line">fmterr: /* Format error. */</div><div class="line">    redisLog(REDIS_WARNING,&quot;Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;&quot;);</div><div class="line">    exit(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="落盘"><a href="#落盘" class="headerlink" title="落盘"></a>落盘</h5><p>redis 每次执行命令都会调用redis.c/call函数，这个函数会调用aof.c/feedAppendOnlyFile函数将每个写命令写入aof buffer，同时如果正在rewrite，也会写入aof rewrite buffer。如果当前db不是aof_selected_db，会在该命令前追加一个select命令，也就是说所有的db都会落入一个aof文件</p>
<p>每次事件循环前都会执行redis.c/beforeSleep函数，该函数会执行flushAppendOnlyFile将buf中的内容刷到磁盘，落盘的时候有三种策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/* Append only defines */</div><div class="line">#define AOF_FSYNC_NO 0 // 交由操作系统决定 操作系统没落盘部分在断电后会丢失</div><div class="line">#define AOF_FSYNC_ALWAYS 1 // 每个命令都落盘，最多丢失一个命令的数据</div><div class="line">#define AOF_FSYNC_EVERYSEC 2 // 每秒落盘，最多丢失一秒的数据（目前我们线上采取的是这种策略）</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</div><div class="line">        /* aof_fsync is defined as fdatasync() for Linux in order to avoid</div><div class="line">         * flushing metadata. */</div><div class="line">        latencyStartMonitor(latency);</div><div class="line">        aof_fsync(server.aof_fd); /* Let&apos;s try to get this data on the disk */</div><div class="line">        latencyEndMonitor(latency);</div><div class="line">        latencyAddSampleIfNeeded(&quot;aof-fsync-always&quot;,latency);</div><div class="line">        server.aof_last_fsync = server.unixtime;</div><div class="line">    &#125; else if ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</div><div class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</div><div class="line">        if (!sync_in_progress) aof_background_fsync(server.aof_fd);</div><div class="line">        server.aof_last_fsync = server.unixtime;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* Define aof_fsync to fdatasync() in Linux and fsync() for all the rest */</div><div class="line">#ifdef __linux__</div><div class="line">#define aof_fsync fdatasync</div><div class="line">#else</div><div class="line">#define aof_fsync fsync</div><div class="line">#endif</div></pre></td></tr></table></figure>
<h5 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h5><p>当aof增长过多的时候会采取aof rewrite来缩小aof文件的大小<br>采取的方式不是去分析aof文件，而是fock一个子进程将内存中的数据dump出一份aof，替换老的aof文件，这当中会忽略已过期的键。如果此时server还在处理命令则将命令也放在rewrite buffer内，当完成aof rewrite后将rewrite buffer中的内容追加到新aof文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">no-appendfsync-on-rewrite  yes</div><div class="line">默认值是 no</div><div class="line">#yes : 在日志重写时，不进行命令追加操作，而只是将其放在缓冲区里，如果子进程和父进程都在写磁盘，可能会造成IO冲突</div></pre></td></tr></table></figure></p>
<p>另外<br>这里还涉及fork子进程，以及内存写时复制等知识</p>
<h5 id="rewrite触发条件"><a href="#rewrite触发条件" class="headerlink" title="rewrite触发条件"></a>rewrite触发条件</h5><ul>
<li>执行命令 bgrewriteaof</li>
<li>自动触发: 满足触发条件时事件循环时会触发<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int aof_no_fsync_on_rewrite;    /* Don&apos;t fsync if a rewrite is in prog. */</div><div class="line">int aof_rewrite_perc;           /* Rewrite AOF if % growth is &gt; M and... */</div><div class="line">off_t aof_rewrite_min_size;     /* the AOF file is at least N bytes. */</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2、rdb"><a href="#2、rdb" class="headerlink" title="2、rdb"></a>2、rdb</h3><p>rdb 文件可以被压缩</p>
<h5 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h5><p> REDIS | RDB-VERSION | SELECT-DB | KEY-VALUE-PAIRS | EOF | CHECK-SUM</p>
<h5 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h5><ul>
<li>执行命令 bgsave</li>
<li>自动触发 经过多少秒且多少个key有改变就进行，可以配置多个<br>我们的线上配置是 save 600 50000，也就是说每600秒 且 至少有50000个key发生变化就执行一次bgsave</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">for (j = 0; j &lt; server.saveparamslen; j++) &#123;</div><div class="line">            struct saveparam *sp = server.saveparams+j;</div><div class="line"></div><div class="line">            /* Save if we reached the given amount of changes,</div><div class="line">             * the given amount of seconds, and if the latest bgsave was</div><div class="line">             * successful or if, in case of an error, at least</div><div class="line">             * REDIS_BGSAVE_RETRY_DELAY seconds already elapsed. */</div><div class="line">            if (server.dirty &gt;= sp-&gt;changes &amp;&amp;</div><div class="line">                server.unixtime-server.lastsave &gt; sp-&gt;seconds &amp;&amp;</div><div class="line">                (server.unixtime-server.lastbgsave_try &gt;</div><div class="line">                 REDIS_BGSAVE_RETRY_DELAY ||</div><div class="line">                 server.lastbgsave_status == REDIS_OK))</div><div class="line">            &#123;</div><div class="line">                redisLog(REDIS_NOTICE,&quot;%d changes in %d seconds. Saving...&quot;,</div><div class="line">                    sp-&gt;changes, (int)sp-&gt;seconds);</div><div class="line">                rdbSaveBackground(server.rdb_filename);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">         &#125;</div></pre></td></tr></table></figure>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="http://doc.redisfans.com" target="_blank" rel="external">http://doc.redisfans.com</a></li>
<li><a href="https://github.com/huangz1990/annotated_redis_sourcel" target="_blank" rel="external">https://github.com/huangz1990/annotated_redis_sourcel</a></li>
<li><a href="!http://redisbook.readthedocs.org/en/latest/">《redis设计与实现》</a></li>
</ul>
</div><div class="tags"><a href="/tags/源码/">源码</a></div><div class="post-nav"><a class="pre" href="/2017/03/13/使用inotify和epoll实现tail命令/">使用inotify和epoll实现tail命令</a><a class="next" href="/2016/07/26/hello-world/">Hello World</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Kategorien</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/学习笔记/" style="font-size: 15px;">学习笔记</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/小玩意/" style="font-size: 15px;">小玩意</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/09/从ThreadLocal到AtomicXXX再到Unsafe/">从ThreadLocal到AtomicXXX再到Unsafe</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/08/java并发包工具之CountDownLatch-CyclicBarrier-Semaphore/">java并发包工具之CountDownLatch/CyclicBarrier/Semaphore</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/07/spring-aop之aspectj的使用教程/">spring aop之aspectj的使用教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/06/Java反射机制学习笔记/">Java反射机制学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/05/java注解学习笔记/">java注解学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/04/Spring-bean生命周期中的钩子/">Spring bean生命周期中的钩子</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/03/ThreadPoolExecutor分析/">ThreadPoolExecutor分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/06/jackson的一个踩坑小记/">jackson的一个踩坑小记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/31/java集合总结/">java集合总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/Spring学习笔记之bean的装配/">Spring学习笔记之bean的装配</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://wismartzy.github.io/" title="wismartzy" target="_blank">wismartzy</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">Wen Er Rd. NO. 48.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>