<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>null</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name">
<meta name="twitter:card" content="summary">
<meta name="twitter:title">
  
    <link rel="alternate" href="/atom.xml" title="null" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">null</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-使用inotify和epoll实现tail命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/13/使用inotify和epoll实现tail命令/" class="article-date">
  <time datetime="2017-03-13T15:29:03.000Z" itemprop="datePublished">2017-03-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/13/使用inotify和epoll实现tail命令/">使用inotify和epoll实现tail命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>tail命令是最常用来看日志改变的工具，比如在执行某个任务时会往本地文件中打入日志，然后使用类似</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tail -f file_path</div></pre></td></tr></table></figure>
<p>的命令来查看最新的日志信息。</p>
<p>要实现这种功能，一般会想到轮询，也就是不断地去读取文件然后比较内容，输出最新的即可，网上搜一下也是有不少这种实现（<a href="http://www.cnblogs.com/iforever/p/5202197.html" target="_blank" rel="external">比如这个</a>）。</p>
<p>显然这不够优雅。</p>
<p>之前听河狸家的技术总监就说到了这个的解决方案，查了一下，发现使用inotify来监听文件变化并向程序发送事件，再用select，poll，epoll来监听inotify产生的事件可以完成tail命令的基本功能。</p>
<p>为此，了解一下相关的调用。</p>
<h3 id="inotify相关"><a href="#inotify相关" class="headerlink" title="inotify相关"></a>inotify相关</h3><h6 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#include&lt;sys/inotify.h&gt;</div></pre></td></tr></table></figure>
<h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int fd = inotify_init();</div></pre></td></tr></table></figure>
<p>此处的fd可以理解为inotify创建的一个通知事件的文件描述符，类似网络编程中的socket，当监听文件变化时，inotify会向fd中写入事件的相关信息。</p>
<h6 id="添加监听"><a href="#添加监听" class="headerlink" title="添加监听"></a>添加监听</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int wd = inotify_add_watch(int fd, const char *path, unit32_t mask);</div></pre></td></tr></table></figure>
<p>这里的fd就是初始化调用inotify_init返回的文件描述符，path就是你要监听的文件路径，mask就是你要监听的变化类型，可以有很多种组合，返回值wd在文档上就这么一句话：</p>
<blockquote>
<p>On success, inotify_add_watch() returns a nonnegative watch descriptor. On error -1 is returned and errno is set appropriately.</p>
</blockquote>
<p>让人摸不着头脑，不知道返回的到底是哪个文件的描述符（事实证明这个wd也不是path文件的描述符）。</p>
<p>mask 可以是以下值的组合</p>
<ul>
<li>IN_ACCESS，文件被访问</li>
<li>IN_ATTRIB，文件属性被修改</li>
<li>IN_CLOSE_WRITE，可写文件被关闭</li>
<li>IN_CLOSE_NOWRITE，不可写文件被关闭</li>
<li>IN_CREATE，文件/文件夹被创建</li>
<li>IN_DELETE，文件/文件夹被删除</li>
<li>IN_DELETE_SELF，被监控的对象本身被删除</li>
<li>IN_MODIFY，文件被修改</li>
<li>IN_MOVE_SELF，被监控的对象本身被移动</li>
<li>IN_MOVED_FROM，文件被移出被监控目录</li>
<li>IN_MOVED_TO，文件被移入被监控目录</li>
<li>IN_OPEN，文件被打开</li>
</ul>
<p>实现tail是用的IN_MODIFY</p>
<p>当调用添加监视对象后就可以坐等事件发生了，当path对应的文件被修改后，fd就变得可读，而且变化的消息也写入了fd，这里我们就可以用select，poll，epoll来监听fd以变相监听文件的变化了。</p>
<h3 id="epoll相关"><a href="#epoll相关" class="headerlink" title="epoll相关"></a>epoll相关</h3><h6 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int epfd = epoll_create(int size);</div></pre></td></tr></table></figure>
<p>创建一个epoll，size是要监听的文件数量</p>
<h6 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int epoll_ctl(int epfd, int op,int fd, struct epoll_event *event)</div></pre></td></tr></table></figure>
<p>epfd就是创建epoll_create返回值，op表示动作，<br>可选的有</p>
<ul>
<li>EPOLL_CTL_ADD：注册新的fd到epfd中；</li>
<li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</li>
<li>EPOLL_CTL_DEL：从epfd中删除一个fd；</li>
</ul>
<p>fd是要监听的文件</p>
<p>event 是需要监听的内容，例如fd可读，可写等等。</p>
<h6 id="等待事件发生"><a href="#等待事件发生" class="headerlink" title="等待事件发生"></a>等待事件发生</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</div></pre></td></tr></table></figure>
<p>前两个参数都是上面的，第三个参数maxevents其实是告诉内核 events 有多大，不会超过创建时的size，第四个参数timeout是指等待的超时时间，比如设为500，表示500毫秒不管有没有事件发生都会返回，设为0则一直阻塞直到事件发生。返回值是发生事件的个数。</p>
<p>介绍完几个系统调用，就可以开始撸代码了。花了几个小时撸了一个简易版本，好在可以用，只限于append。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">#include &lt;fcntl.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;errno.h&gt;</div><div class="line">#include &lt;sys/inotify.h&gt;</div><div class="line">#include &lt;sys/epoll.h&gt;</div><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/stat.h&gt;</div><div class="line">#include &lt;errno.h&gt;</div><div class="line"></div><div class="line">#define BUFSIZE 81</div><div class="line"></div><div class="line">int main(int argc, char* argv[]) &#123;</div><div class="line">    printf(&quot;LOG:argc = %d\n&quot;, argc);</div><div class="line">    printf(&quot;LOG:argc[1] = %s\n&quot;, argv[1]);</div><div class="line">    int fd = inotify_init();</div><div class="line">    printf(&quot;LOG:fd = %d\n&quot;, fd);</div><div class="line">    if (fd &lt; 0) &#123;</div><div class="line">        printf(&quot;LOG:inotify_init error\n&quot;);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    int wd = inotify_add_watch(fd, argv[1], IN_MODIFY);</div><div class="line">    printf(&quot;LOG:wd = %d\n&quot;, wd);</div><div class="line">    if (wd &lt; 0) &#123;</div><div class="line">        printf(&quot;LOG:inotify_add_watch error&quot;);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    int epfd = epoll_create(1);</div><div class="line">    printf(&quot;LOG:epfd = %d\n&quot;, epfd);</div><div class="line">    if (epfd &lt; 0) &#123;</div><div class="line">        printf(&quot;LOG:epoll_create error\n&quot;);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    struct epoll_event event;</div><div class="line">    event.events = EPOLLIN | EPOLLET;</div><div class="line">    event.data.fd = fd;</div><div class="line"></div><div class="line">    int re = epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);     </div><div class="line">    printf(&quot;LOG:re = %d\n&quot;, re);</div><div class="line">    if (re != 0) &#123;</div><div class="line">        printf(&quot;LOG:epoll_ctl error:%s\n&quot;, strerror(errno));</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ssize_t n;</div><div class="line">    ssize_t tmp;</div><div class="line">    int file_fd = open(argv[1], O_RDONLY);</div><div class="line">    printf(&quot;LOG:file_fd = %d\n&quot;, file_fd);</div><div class="line">    if (file_fd == -1) &#123;</div><div class="line">        printf(&quot;LOG:open error\n&quot;);</div><div class="line">        return -1;</div><div class="line">    &#125;</div><div class="line">    char buf[BUFSIZE];</div><div class="line">    </div><div class="line">    int seek_re;    </div><div class="line"></div><div class="line">    while (1) &#123;</div><div class="line">        int num = epoll_wait(epfd, &amp;event, 1, -1);</div><div class="line">        printf(&quot;LOG:epoll_wait num = %d\n&quot;, num);</div><div class="line">        if (num &gt; 0) &#123;</div><div class="line">            // 这里是为了读掉消息而不重复通知</div><div class="line">            tmp = read(fd, buf, BUFSIZE);</div><div class="line">            seek_re = lseek(file_fd, (off_t) -1, SEEK_CUR);</div><div class="line">            n = read(file_fd, buf, BUFSIZE);</div><div class="line">            if (n == -1) &#123;</div><div class="line">		        printf(&quot;break\n&quot;);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            if (n &gt; 0) &#123;</div><div class="line">                printf(&quot;%s&quot;, buf);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        printf(&quot;LOG:new loop\n&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc mytail.c -o mytail</div></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">touch ./test.txt</div><div class="line">./mytail ./test.txt</div></pre></td></tr></table></figure>
<p>另开一个终端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">echo aa &gt; ./test.txt</div><div class="line">echo aabb &gt; ./test.txt</div><div class="line">echo aabbcc &gt; ./test.txt</div></pre></td></tr></table></figure>
<p>可以看到类似tail的输出，不过多了一些log。</p>
<h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ul>
<li>Q：最后为啥我用vim编辑test.txt文件再保存却没有效果呢？</li>
<li><p>A：其实是这样的，vim这类编辑器并没有修改文件，而是copy一份来编辑，编辑完了替换掉原先的文件，如果要实现这个，可以用notify监听文件的删除移动等。</p>
</li>
<li><p>Q：为啥是epoll而不是select，poll？</p>
</li>
<li><p>A：这个纯属好玩，用select，poll也能达到相同的效果，在监听少数文件下是没有区别的，网上说的差别主要还是针对监听大量文件的情况下，通常也是网络请求高并发下，epoll会突显绝对优势，这里epoll只监听inotify的fd文件，永远只有一个，所以更没有区别了。</p>
</li>
<li><p>Q：既然epoll可以监听inotify的事件，为何epoll不直接监听变化的文件而是要绕这么大一个弯？</p>
</li>
<li>A：linux中的epoll本身不支持监听本地文件，只能监听类似inotify和socket这种文件（可以理解为消息管道，并不存储信息），当有事件到达这两种文件，这两种文件被写入了信息，并且变得可读，本地文件写入了新东西并没有变得可读。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/13/使用inotify和epoll实现tail命令/" data-id="cj08aqmau0000brrdqhp9vatr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-redis存储分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/08/redis存储分析/" class="article-date">
  <time datetime="2016-12-08T08:57:23.000Z" itemprop="datePublished">2016-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/08/redis存储分析/">redis存储分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、内存"><a href="#一、内存" class="headerlink" title="一、内存"></a>一、内存</h2><h3 id="1、几个关键的数据结构"><a href="#1、几个关键的数据结构" class="headerlink" title="1、几个关键的数据结构"></a>1、几个关键的数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct redisServer &#123;</div><div class="line">    ...</div><div class="line">    redisDb *db;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef struct redisDb &#123;</div><div class="line">    dict *dict;                 /* The keyspace for this DB */</div><div class="line">    dict *expires;              /* Timeout of keys with a timeout set */</div><div class="line">    dict *blocking_keys;</div><div class="line">    dict *ready_keys;</div><div class="line">    dict *watched_keys;</div><div class="line">    struct evictionPoolEntry *eviction_pool;</div><div class="line">    int id;</div><div class="line">    long long avg_ttl;</div><div class="line">&#125; redisDb;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef struct dict &#123;</div><div class="line">    dictType *type;</div><div class="line">    void *privdata;</div><div class="line">    dictht ht[2];</div><div class="line">    long rehashidx; /* rehashing not in progress if rehashidx == -1 */</div><div class="line">    int iterators; /* number of iterators currently running */</div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef struct dictht &#123;</div><div class="line">    dictEntry **table;</div><div class="line">    unsigned long size;</div><div class="line">    unsigned long sizemask;</div><div class="line">    unsigned long used;</div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">typedef struct dictEntry &#123;</div><div class="line">    void *key;</div><div class="line">    union &#123;</div><div class="line">        void *val;</div><div class="line">        uint64_t u64;</div><div class="line">        int64_t s64;</div><div class="line">        double d;</div><div class="line">    &#125; v;</div><div class="line">    struct dictEntry *next;</div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure>
<p><img src="http://b0.hucdn.com/party/2016/11/upload_478e6a064820f8628efc1beea28283d2_1034x355.JPG" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">dictEntry *dictFind(dict *d, const void *key)</div><div class="line">&#123;</div><div class="line">    dictEntry *he;</div><div class="line">    unsigned int h, idx, table;</div><div class="line"></div><div class="line">    if (d-&gt;ht[0].size == 0) return NULL; /* We don&apos;t have a table at all */</div><div class="line">    if (dictIsRehashing(d)) _dictRehashStep(d);// 渐进式rehash迁移数据</div><div class="line">    h = dictHashKey(d, key);</div><div class="line">    for (table = 0; table &lt;= 1; table++) &#123;</div><div class="line">        idx = h &amp; d-&gt;ht[table].sizemask;</div><div class="line">        he = d-&gt;ht[table].table[idx];</div><div class="line">        while(he) &#123;</div><div class="line">            if (dictCompareKeys(d, key, he-&gt;key))</div><div class="line">                return he;</div><div class="line">            he = he-&gt;next;</div><div class="line">        &#125;</div><div class="line">        if (!dictIsRehashing(d)) return NULL;</div><div class="line">    &#125;</div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、rehash"><a href="#2、rehash" class="headerlink" title="2、rehash"></a>2、rehash</h3><h4 id="1）rehash标志"><a href="#1）rehash标志" class="headerlink" title="1）rehash标志"></a>1）rehash标志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define dictIsRehashing(d) ((d)-&gt;rehashidx != -1)</div></pre></td></tr></table></figure>
<p>-1 表示没有rehash，&gt;=1 表示 该index后面的没有进行rehash</p>
<h4 id="2）rehash过程"><a href="#2）rehash过程" class="headerlink" title="2）rehash过程"></a>2）rehash过程</h4><p>渐进式rehash 见上述dictFind实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">/* Performs N steps of incremental rehashing. Returns 1 if there are still</div><div class="line"> * keys to move from the old to the new hash table, otherwise 0 is returned.</div><div class="line"> *</div><div class="line"> * Note that a rehashing step consists in moving a bucket (that may have more</div><div class="line"> * than one key as we use chaining) from the old to the new hash table, however</div><div class="line"> * since part of the hash table may be composed of empty spaces, it is not</div><div class="line"> * guaranteed that this function will rehash even a single bucket, since it</div><div class="line"> * will visit at max N*10 empty buckets in total, otherwise the amount of</div><div class="line"> * work it does would be unbound and the function may block for a long time. */</div><div class="line">int dictRehash(dict *d, int n) &#123;</div><div class="line">    int empty_visits = n*10; /* Max number of empty buckets to visit. */</div><div class="line">    if (!dictIsRehashing(d)) return 0;</div><div class="line"></div><div class="line">    while(n-- &amp;&amp; d-&gt;ht[0].used != 0) &#123;</div><div class="line">        dictEntry *de, *nextde;</div><div class="line"></div><div class="line">        /* Note that rehashidx can&apos;t overflow as we are sure there are more</div><div class="line">         * elements because ht[0].used != 0 */</div><div class="line">        assert(d-&gt;ht[0].size &gt; (unsigned long)d-&gt;rehashidx);</div><div class="line">        while(d-&gt;ht[0].table[d-&gt;rehashidx] == NULL) &#123;</div><div class="line">            d-&gt;rehashidx++;</div><div class="line">            if (--empty_visits == 0) return 1;</div><div class="line">        &#125;</div><div class="line">        de = d-&gt;ht[0].table[d-&gt;rehashidx];</div><div class="line">        /* Move all the keys in this bucket from the old to the new hash HT */</div><div class="line">        while(de) &#123;</div><div class="line">            unsigned int h;</div><div class="line"></div><div class="line">            nextde = de-&gt;next;</div><div class="line">            /* Get the index in the new hash table */</div><div class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[1].sizemask;</div><div class="line">            de-&gt;next = d-&gt;ht[1].table[h];</div><div class="line">            d-&gt;ht[1].table[h] = de;</div><div class="line">            d-&gt;ht[0].used--;</div><div class="line">            d-&gt;ht[1].used++;</div><div class="line">            de = nextde;</div><div class="line">        &#125;</div><div class="line">        d-&gt;ht[0].table[d-&gt;rehashidx] = NULL;</div><div class="line">        d-&gt;rehashidx++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Check if we already rehashed the whole table... */</div><div class="line">    if (d-&gt;ht[0].used == 0) &#123;</div><div class="line">        zfree(d-&gt;ht[0].table);</div><div class="line">        d-&gt;ht[0] = d-&gt;ht[1];</div><div class="line">        _dictReset(&amp;d-&gt;ht[1]);</div><div class="line">        d-&gt;rehashidx = -1;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* More to rehash... */</div><div class="line">    return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3）rehash条件"><a href="#3）rehash条件" class="headerlink" title="3）rehash条件"></a>3）rehash条件</h4><p>负载因子 = ht[0].used / ht[0].size<br>负载因子 &gt;= 5 说明 hash冲突已经很明显 =&gt; 扩张table<br>负载因子 &lt; 0.1 说明表太大 =&gt; 收缩</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* Using dictEnableResize() / dictDisableResize() we make possible to</div><div class="line"> * enable/disable resizing of the hash table as needed. This is very important</div><div class="line"> * for Redis, as we use copy-on-write and don&apos;t want to move too much memory</div><div class="line"> * around when there is a child performing saving operations.</div><div class="line"> *</div><div class="line"> * Note that even when dict_can_resize is set to 0, not all resizes are</div><div class="line"> * prevented: a hash table is still allowed to grow if the ratio between</div><div class="line"> * the number of elements and the buckets &gt; dict_force_resize_ratio. */</div><div class="line">static int dict_can_resize = 1;</div><div class="line">static unsigned int dict_force_resize_ratio = 5;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">int htNeedsResize(dict *dict) &#123;</div><div class="line">    long long size, used;</div><div class="line"></div><div class="line">    size = dictSlots(dict);</div><div class="line">    used = dictSize(dict);</div><div class="line">    return (size &amp;&amp; used &amp;&amp; size &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</div><div class="line">            (used*100/size &lt; REDIS_HT_MINFILL));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/* Expand the hash table if needed */</div><div class="line">static int _dictExpandIfNeeded(dict *d)</div><div class="line">&#123;</div><div class="line">    /* Incremental rehashing already in progress. Return. */</div><div class="line">    if (dictIsRehashing(d)) return DICT_OK;</div><div class="line"></div><div class="line">    /* If the hash table is empty expand it to the initial size. */</div><div class="line">    if (d-&gt;ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);</div><div class="line"></div><div class="line">    /* If we reached the 1:1 ratio, and we are allowed to resize the hash</div><div class="line">     * table (global setting) or we should avoid it but the ratio between</div><div class="line">     * elements/buckets is over the &quot;safe&quot; threshold, we resize doubling</div><div class="line">     * the number of buckets. */</div><div class="line">    if (d-&gt;ht[0].used &gt;= d-&gt;ht[0].size &amp;&amp;</div><div class="line">        (dict_can_resize ||</div><div class="line">         d-&gt;ht[0].used/d-&gt;ht[0].size &gt; dict_force_resize_ratio))</div><div class="line">    &#123;</div><div class="line">        return dictExpand(d, d-&gt;ht[0].used*2);</div><div class="line">    &#125;</div><div class="line">    return DICT_OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>used和size分别是什么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">dictEntry *dictAddRaw(dict *d, void *key)</div><div class="line">&#123;</div><div class="line">    int index;</div><div class="line">    dictEntry *entry;</div><div class="line">    dictht *ht;</div><div class="line"></div><div class="line">    if (dictIsRehashing(d)) _dictRehashStep(d);</div><div class="line"></div><div class="line">    /* Get the index of the new element, or -1 if</div><div class="line">     * the element already exists. */</div><div class="line">    if ((index = _dictKeyIndex(d, key)) == -1)</div><div class="line">        return NULL;</div><div class="line"></div><div class="line">    /* Allocate the memory and store the new entry */</div><div class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[1] : &amp;d-&gt;ht[0];</div><div class="line">    entry = zmalloc(sizeof(*entry));</div><div class="line">    entry-&gt;next = ht-&gt;table[index];</div><div class="line">    ht-&gt;table[index] = entry;</div><div class="line">    ht-&gt;used++;</div><div class="line"></div><div class="line">    /* Set the hash entry fields. */</div><div class="line">    dictSetKey(d, entry, key);</div><div class="line">    return entry;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、过期机制"><a href="#3、过期机制" class="headerlink" title="3、过期机制"></a>3、过期机制</h3><p>单独维护 expires，见上述redisDB</p>
<p>获取key的过期时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/* Return the expire time of the specified key, or -1 if no expire</div><div class="line"> * is associated with this key (i.e. the key is non volatile) */</div><div class="line">long long getExpire(redisDb *db, robj *key) &#123;</div><div class="line">    dictEntry *de;</div><div class="line"></div><div class="line">    /* No expire? return ASAP */</div><div class="line">    if (dictSize(db-&gt;expires) == 0 ||</div><div class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == NULL) return -1;</div><div class="line"></div><div class="line">    /* The entry was found in the expire dict, this means it should also</div><div class="line">     * be present in the main dict (safety check). */</div><div class="line">    redisAssertWithInfo(NULL,key,dictFind(db-&gt;dict,key-&gt;ptr) != NULL);</div><div class="line">    return dictGetSignedIntegerVal(de);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面的函数是get命令的实现，由此可看出key过期是一种惰性删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">robj *lookupKeyRead(redisDb *db, robj *key) &#123;</div><div class="line">    robj *val;</div><div class="line"></div><div class="line">    expireIfNeeded(db,key);</div><div class="line">    val = lookupKey(db,key);</div><div class="line">    if (val == NULL)</div><div class="line">        server.stat_keyspace_misses++;</div><div class="line">    else</div><div class="line">        server.stat_keyspace_hits++;</div><div class="line">    return val;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>随机淘汰<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div></pre></td><td class="code"><pre><div class="line">/* ======================= Cron: called every 100 ms ======================== */</div><div class="line"></div><div class="line">/* Helper function for the activeExpireCycle() function.</div><div class="line"> * This function will try to expire the key that is stored in the hash table</div><div class="line"> * entry &apos;de&apos; of the &apos;expires&apos; hash table of a Redis database.</div><div class="line"> *</div><div class="line"> * If the key is found to be expired, it is removed from the database and</div><div class="line"> * 1 is returned. Otherwise no operation is performed and 0 is returned.</div><div class="line"> *</div><div class="line"> * When a key is expired, server.stat_expiredkeys is incremented.</div><div class="line"> *</div><div class="line"> * The parameter &apos;now&apos; is the current time in milliseconds as is passed</div><div class="line"> * to the function to avoid too many gettimeofday() syscalls. */</div><div class="line">int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) &#123;</div><div class="line">    long long t = dictGetSignedIntegerVal(de);</div><div class="line">    if (now &gt; t) &#123;</div><div class="line">        sds key = dictGetKey(de);</div><div class="line">        robj *keyobj = createStringObject(key,sdslen(key));</div><div class="line"></div><div class="line">        propagateExpire(db,keyobj);</div><div class="line">        dbDelete(db,keyobj);</div><div class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,</div><div class="line">            &quot;expired&quot;,keyobj,db-&gt;id);</div><div class="line">        decrRefCount(keyobj);</div><div class="line">        server.stat_expiredkeys++;</div><div class="line">        return 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Try to expire a few timed out keys. The algorithm used is adaptive and</div><div class="line"> * will use few CPU cycles if there are few expiring keys, otherwise</div><div class="line"> * it will get more aggressive to avoid that too much memory is used by</div><div class="line"> * keys that can be removed from the keyspace.</div><div class="line"> *</div><div class="line"> * No more than REDIS_DBCRON_DBS_PER_CALL databases are tested at every</div><div class="line"> * iteration.</div><div class="line"> *</div><div class="line"> * This kind of call is used when Redis detects that timelimit_exit is</div><div class="line"> * true, so there is more work to do, and we do it more incrementally from</div><div class="line"> * the beforeSleep() function of the event loop.</div><div class="line"> *</div><div class="line"> * Expire cycle type:</div><div class="line"> *</div><div class="line"> * If type is ACTIVE_EXPIRE_CYCLE_FAST the function will try to run a</div><div class="line"> * &quot;fast&quot; expire cycle that takes no longer than EXPIRE_FAST_CYCLE_DURATION</div><div class="line"> * microseconds, and is not repeated again before the same amount of time.</div><div class="line"> *</div><div class="line"> * If type is ACTIVE_EXPIRE_CYCLE_SLOW, that normal expire cycle is</div><div class="line"> * executed, where the time limit is a percentage of the REDIS_HZ period</div><div class="line"> * as specified by the REDIS_EXPIRELOOKUPS_TIME_PERC define. */</div><div class="line"></div><div class="line">void activeExpireCycle(int type) &#123;</div><div class="line">    /* This function has some global state in order to continue the work</div><div class="line">     * incrementally across calls. */</div><div class="line">    static unsigned int current_db = 0; /* Last DB tested. */</div><div class="line">    static int timelimit_exit = 0;      /* Time limit hit in previous call? */</div><div class="line">    static long long last_fast_cycle = 0; /* When last fast cycle ran. */</div><div class="line"></div><div class="line">    int j, iteration = 0;</div><div class="line">    int dbs_per_call = REDIS_DBCRON_DBS_PER_CALL;</div><div class="line">    long long start = ustime(), timelimit;</div><div class="line"></div><div class="line">    if (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</div><div class="line">        /* Don&apos;t start a fast cycle if the previous cycle did not exited</div><div class="line">         * for time limt. Also don&apos;t repeat a fast cycle for the same period</div><div class="line">         * as the fast cycle total duration itself. */</div><div class="line">        if (!timelimit_exit) return;</div><div class="line">        if (start &lt; last_fast_cycle + ACTIVE_EXPIRE_CYCLE_FAST_DURATION*2) return;</div><div class="line">        last_fast_cycle = start;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* We usually should test REDIS_DBCRON_DBS_PER_CALL per iteration, with</div><div class="line">     * two exceptions:</div><div class="line">     *</div><div class="line">     * 1) Don&apos;t test more DBs than we have.</div><div class="line">     * 2) If last time we hit the time limit, we want to scan all DBs</div><div class="line">     * in this iteration, as there is work to do in some DB and we don&apos;t want</div><div class="line">     * expired keys to use memory for too much time. */</div><div class="line">    if (dbs_per_call &gt; server.dbnum || timelimit_exit)</div><div class="line">        dbs_per_call = server.dbnum;</div><div class="line"></div><div class="line">    /* We can use at max ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC percentage of CPU time</div><div class="line">     * per iteration. Since this function gets called with a frequency of</div><div class="line">     * server.hz times per second, the following is the max amount of</div><div class="line">     * microseconds we can spend in this function. */</div><div class="line">    timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;</div><div class="line">    timelimit_exit = 0;</div><div class="line">    if (timelimit &lt;= 0) timelimit = 1;</div><div class="line"></div><div class="line">    if (type == ACTIVE_EXPIRE_CYCLE_FAST)</div><div class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; /* in microseconds. */</div><div class="line"></div><div class="line">    for (j = 0; j &lt; dbs_per_call; j++) &#123;</div><div class="line">        int expired;</div><div class="line">        redisDb *db = server.db+(current_db % server.dbnum);</div><div class="line"></div><div class="line">        /* Increment the DB now so we are sure if we run out of time</div><div class="line">         * in the current DB we&apos;ll restart from the next. This allows to</div><div class="line">         * distribute the time evenly across DBs. */</div><div class="line">        current_db++;</div><div class="line"></div><div class="line">        /* Continue to expire if at the end of the cycle more than 25%</div><div class="line">         * of the keys were expired. */</div><div class="line">        do &#123;</div><div class="line">            unsigned long num, slots;</div><div class="line">            long long now, ttl_sum;</div><div class="line">            int ttl_samples;</div><div class="line"></div><div class="line">            /* If there is nothing to expire try next DB ASAP. */</div><div class="line">            if ((num = dictSize(db-&gt;expires)) == 0) &#123;</div><div class="line">                db-&gt;avg_ttl = 0;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            slots = dictSlots(db-&gt;expires);</div><div class="line">            now = mstime();</div><div class="line"></div><div class="line">            /* When there are less than 1% filled slots getting random</div><div class="line">             * keys is expensive, so stop here waiting for better times...</div><div class="line">             * The dictionary will be resized asap. */</div><div class="line">            if (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</div><div class="line">                (num*100/slots &lt; 1)) break;</div><div class="line"></div><div class="line">            /* The main collection cycle. Sample random keys among keys</div><div class="line">             * with an expire set, checking for expired ones. */</div><div class="line">            expired = 0;</div><div class="line">            ttl_sum = 0;</div><div class="line">            ttl_samples = 0;</div><div class="line"></div><div class="line">            if (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</div><div class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</div><div class="line"></div><div class="line">            while (num--) &#123;</div><div class="line">                dictEntry *de;</div><div class="line">                long long ttl;</div><div class="line"></div><div class="line">                if ((de = dictGetRandomKey(db-&gt;expires)) == NULL) break;</div><div class="line">                ttl = dictGetSignedIntegerVal(de)-now;</div><div class="line">                if (activeExpireCycleTryExpire(db,de,now)) expired++;</div><div class="line">                if (ttl &lt; 0) ttl = 0;</div><div class="line">                ttl_sum += ttl;</div><div class="line">                ttl_samples++;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* Update the average TTL stats for this database. */</div><div class="line">            if (ttl_samples) &#123;</div><div class="line">                long long avg_ttl = ttl_sum/ttl_samples;</div><div class="line"></div><div class="line">                if (db-&gt;avg_ttl == 0) db-&gt;avg_ttl = avg_ttl;</div><div class="line">                /* Smooth the value averaging with the previous one. */</div><div class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl+avg_ttl)/2;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            /* We can&apos;t block forever here even if there are many keys to</div><div class="line">             * expire. So after a given amount of milliseconds return to the</div><div class="line">             * caller waiting for the other active expire cycle. */</div><div class="line">            iteration++;</div><div class="line">            if ((iteration &amp; 0xf) == 0) &#123; /* check once every 16 iterations. */</div><div class="line">                long long elapsed = ustime()-start;</div><div class="line"></div><div class="line">                latencyAddSampleIfNeeded(&quot;expire-cycle&quot;,elapsed/1000);</div><div class="line">                if (elapsed &gt; timelimit) timelimit_exit = 1;</div><div class="line">            &#125;</div><div class="line">            if (timelimit_exit) return;</div><div class="line">            /* We don&apos;t repeat the cycle if there are less than 25% of keys</div><div class="line">             * found expired in the current DB. */</div><div class="line">        &#125; while (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/4);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>也就是说每秒钟 最多淘汰10个过期的key</p>
<h2 id="二、持久化"><a href="#二、持久化" class="headerlink" title="二、持久化"></a>二、持久化</h2><p>redis服务启动的时候，会去load持久化数据，优先级是有aof则aof，没有aof就rdb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/* Function called at startup to load RDB or AOF file in memory. */</div><div class="line">void loadDataFromDisk(void) &#123;</div><div class="line">    long long start = ustime();</div><div class="line">    if (server.aof_state == REDIS_AOF_ON) &#123;</div><div class="line">        if (loadAppendOnlyFile(server.aof_filename) == REDIS_OK)</div><div class="line">            redisLog(REDIS_NOTICE,&quot;DB loaded from append only file: %.3f seconds&quot;,(float)(ustime()-start)/1000000);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (rdbLoad(server.rdb_filename) == REDIS_OK) &#123;</div><div class="line">            redisLog(REDIS_NOTICE,&quot;DB loaded from disk: %.3f seconds&quot;,</div><div class="line">                (float)(ustime()-start)/1000000);</div><div class="line">        &#125; else if (errno != ENOENT) &#123;</div><div class="line">            redisLog(REDIS_WARNING,&quot;Fatal error loading the DB: %s. Exiting.&quot;,strerror(errno));</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1、aof"><a href="#1、aof" class="headerlink" title="1、aof"></a>1、aof</h3><h5 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h5><p>以redis协议的格式存储每一条写命令<br>协议类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">命令：SET HENRY  HENRYFAN</div><div class="line">协议：</div><div class="line">*3\r\n</div><div class="line">$3\r\n</div><div class="line">SET\r\n</div><div class="line">$5\r\n</div><div class="line">HENRY\r\n</div><div class="line">$8\r\n</div><div class="line">HENRYFAN\r\n</div></pre></td></tr></table></figure></p>
<h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>server启动时aof加载会不处理客户端的请求（不是阻塞，返回错误）<br>加载时，建立一个fake客户端，循环执行aof中的命令（见aof.c/loadAppendOnlyFile）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div></pre></td><td class="code"><pre><div class="line">/* Replay the append log file. On success REDIS_OK is returned. On non fatal</div><div class="line"> * error (the append only file is zero-length) REDIS_ERR is returned. On</div><div class="line"> * fatal error an error message is logged and the program exists. */</div><div class="line">int loadAppendOnlyFile(char *filename) &#123;</div><div class="line">    struct redisClient *fakeClient;</div><div class="line">    FILE *fp = fopen(filename,&quot;r&quot;);</div><div class="line">    struct redis_stat sb;</div><div class="line">    int old_aof_state = server.aof_state;</div><div class="line">    long loops = 0;</div><div class="line">    off_t valid_up_to = 0; /* Offset of the latest well-formed command loaded. */</div><div class="line"></div><div class="line">    if (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != -1 &amp;&amp; sb.st_size == 0) &#123;</div><div class="line">        server.aof_current_size = 0;</div><div class="line">        fclose(fp);</div><div class="line">        return REDIS_ERR;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (fp == NULL) &#123;</div><div class="line">        redisLog(REDIS_WARNING,&quot;Fatal error: can&apos;t open the append log file for reading: %s&quot;,strerror(errno));</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* Temporarily disable AOF, to prevent EXEC from feeding a MULTI</div><div class="line">     * to the same file we&apos;re about to read. */</div><div class="line">    server.aof_state = REDIS_AOF_OFF;</div><div class="line"></div><div class="line">    fakeClient = createFakeClient();</div><div class="line">    startLoading(fp);</div><div class="line"></div><div class="line">    while(1) &#123;</div><div class="line">        int argc, j;</div><div class="line">        unsigned long len;</div><div class="line">        robj **argv;</div><div class="line">        char buf[128];</div><div class="line">        sds argsds;</div><div class="line">        struct redisCommand *cmd;</div><div class="line"></div><div class="line">        /* Serve the clients from time to time */</div><div class="line">        if (!(loops++ % 1000)) &#123;</div><div class="line">            loadingProgress(ftello(fp));</div><div class="line">            processEventsWhileBlocked();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (fgets(buf,sizeof(buf),fp) == NULL) &#123;</div><div class="line">            if (feof(fp))</div><div class="line">                break;</div><div class="line">            else</div><div class="line">                goto readerr;</div><div class="line">        &#125;</div><div class="line">        if (buf[0] != &apos;*&apos;) goto fmterr;</div><div class="line">        if (buf[1] == &apos;\0&apos;) goto readerr;</div><div class="line">        argc = atoi(buf+1);</div><div class="line">        if (argc &lt; 1) goto fmterr;</div><div class="line"></div><div class="line">        argv = zmalloc(sizeof(robj*)*argc);</div><div class="line">        fakeClient-&gt;argc = argc;</div><div class="line">        fakeClient-&gt;argv = argv;</div><div class="line"></div><div class="line">        for (j = 0; j &lt; argc; j++) &#123;</div><div class="line">            if (fgets(buf,sizeof(buf),fp) == NULL) &#123;</div><div class="line">                fakeClient-&gt;argc = j; /* Free up to j-1. */</div><div class="line">                freeFakeClientArgv(fakeClient);</div><div class="line">                goto readerr;</div><div class="line">            &#125;</div><div class="line">            if (buf[0] != &apos;$&apos;) goto fmterr;</div><div class="line">            len = strtol(buf+1,NULL,10);</div><div class="line">            argsds = sdsnewlen(NULL,len);</div><div class="line">            if (len &amp;&amp; fread(argsds,len,1,fp) == 0) &#123;</div><div class="line">                sdsfree(argsds);</div><div class="line">                fakeClient-&gt;argc = j; /* Free up to j-1. */</div><div class="line">                freeFakeClientArgv(fakeClient);</div><div class="line">                goto readerr;</div><div class="line">            &#125;</div><div class="line">            argv[j] = createObject(REDIS_STRING,argsds);</div><div class="line">            if (fread(buf,2,1,fp) == 0) &#123;</div><div class="line">                fakeClient-&gt;argc = j+1; /* Free up to j. */</div><div class="line">                freeFakeClientArgv(fakeClient);</div><div class="line">                goto readerr; /* discard CRLF */</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Command lookup */</div><div class="line">        cmd = lookupCommand(argv[0]-&gt;ptr);</div><div class="line">        if (!cmd) &#123;</div><div class="line">            redisLog(REDIS_WARNING,&quot;Unknown command &apos;%s&apos; reading the append only file&quot;, (char*)argv[0]-&gt;ptr);</div><div class="line">            exit(1);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        /* Run the command in the context of a fake client */</div><div class="line">        cmd-&gt;proc(fakeClient);</div><div class="line"></div><div class="line">        /* The fake client should not have a reply */</div><div class="line">        redisAssert(fakeClient-&gt;bufpos == 0 &amp;&amp; listLength(fakeClient-&gt;reply) == 0);</div><div class="line">        /* The fake client should never get blocked */</div><div class="line">        redisAssert((fakeClient-&gt;flags &amp; REDIS_BLOCKED) == 0);</div><div class="line"></div><div class="line">        /* Clean up. Command code may have changed argv/argc so we use the</div><div class="line">         * argv/argc of the client instead of the local variables. */</div><div class="line">        freeFakeClientArgv(fakeClient);</div><div class="line">        if (server.aof_load_truncated) valid_up_to = ftello(fp);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* This point can only be reached when EOF is reached without errors.</div><div class="line">     * If the client is in the middle of a MULTI/EXEC, log error and quit. */</div><div class="line">    if (fakeClient-&gt;flags &amp; REDIS_MULTI) goto uxeof;</div><div class="line"></div><div class="line">loaded_ok: /* DB loaded, cleanup and return REDIS_OK to the caller. */</div><div class="line">    fclose(fp);</div><div class="line">    freeFakeClient(fakeClient);</div><div class="line">    server.aof_state = old_aof_state;</div><div class="line">    stopLoading();</div><div class="line">    aofUpdateCurrentSize();</div><div class="line">    server.aof_rewrite_base_size = server.aof_current_size;</div><div class="line">    return REDIS_OK;</div><div class="line"></div><div class="line">readerr: /* Read error. If feof(fp) is true, fall through to unexpected EOF. */</div><div class="line">    if (!feof(fp)) &#123;</div><div class="line">        redisLog(REDIS_WARNING,&quot;Unrecoverable error reading the append only file: %s&quot;, strerror(errno));</div><div class="line">        exit(1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">uxeof: /* Unexpected AOF end of file. */</div><div class="line">    if (server.aof_load_truncated) &#123;</div><div class="line">        redisLog(REDIS_WARNING,&quot;!!! Warning: short read while loading the AOF file !!!&quot;);</div><div class="line">        redisLog(REDIS_WARNING,&quot;!!! Truncating the AOF at offset %llu !!!&quot;,</div><div class="line">            (unsigned long long) valid_up_to);</div><div class="line">        if (valid_up_to == -1 || truncate(filename,valid_up_to) == -1) &#123;</div><div class="line">            if (valid_up_to == -1) &#123;</div><div class="line">                redisLog(REDIS_WARNING,&quot;Last valid command offset is invalid&quot;);</div><div class="line">            &#125; else &#123;</div><div class="line">                redisLog(REDIS_WARNING,&quot;Error truncating the AOF file: %s&quot;,</div><div class="line">                    strerror(errno));</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            /* Make sure the AOF file descriptor points to the end of the</div><div class="line">             * file after the truncate call. */</div><div class="line">            if (server.aof_fd != -1 &amp;&amp; lseek(server.aof_fd,0,SEEK_END) == -1) &#123;</div><div class="line">                redisLog(REDIS_WARNING,&quot;Can&apos;t seek the end of the AOF file: %s&quot;,</div><div class="line">                    strerror(errno));</div><div class="line">            &#125; else &#123;</div><div class="line">                redisLog(REDIS_WARNING,</div><div class="line">                    &quot;AOF loaded anyway because aof-load-truncated is enabled&quot;);</div><div class="line">                goto loaded_ok;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    redisLog(REDIS_WARNING,&quot;Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;. 2) Alternatively you can set the &apos;aof-load-truncated&apos; configuration option to yes and restart the server.&quot;);</div><div class="line">    exit(1);</div><div class="line"></div><div class="line">fmterr: /* Format error. */</div><div class="line">    redisLog(REDIS_WARNING,&quot;Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;&quot;);</div><div class="line">    exit(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="落盘"><a href="#落盘" class="headerlink" title="落盘"></a>落盘</h5><p>redis 每次执行命令都会调用redis.c/call函数，这个函数会调用aof.c/feedAppendOnlyFile函数将每个写命令写入aof buffer，同时如果正在rewrite，也会写入aof rewrite buffer。如果当前db不是aof_selected_db，会在该命令前追加一个select命令，也就是说所有的db都会落入一个aof文件</p>
<p>每次事件循环前都会执行redis.c/beforeSleep函数，该函数会执行flushAppendOnlyFile将buf中的内容刷到磁盘，落盘的时候有三种策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/* Append only defines */</div><div class="line">#define AOF_FSYNC_NO 0 // 交由操作系统决定 操作系统没落盘部分在断电后会丢失</div><div class="line">#define AOF_FSYNC_ALWAYS 1 // 每个命令都落盘，最多丢失一个命令的数据</div><div class="line">#define AOF_FSYNC_EVERYSEC 2 // 每秒落盘，最多丢失一秒的数据（目前我们线上采取的是这种策略）</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">if (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</div><div class="line">        /* aof_fsync is defined as fdatasync() for Linux in order to avoid</div><div class="line">         * flushing metadata. */</div><div class="line">        latencyStartMonitor(latency);</div><div class="line">        aof_fsync(server.aof_fd); /* Let&apos;s try to get this data on the disk */</div><div class="line">        latencyEndMonitor(latency);</div><div class="line">        latencyAddSampleIfNeeded(&quot;aof-fsync-always&quot;,latency);</div><div class="line">        server.aof_last_fsync = server.unixtime;</div><div class="line">    &#125; else if ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</div><div class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</div><div class="line">        if (!sync_in_progress) aof_background_fsync(server.aof_fd);</div><div class="line">        server.aof_last_fsync = server.unixtime;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* Define aof_fsync to fdatasync() in Linux and fsync() for all the rest */</div><div class="line">#ifdef __linux__</div><div class="line">#define aof_fsync fdatasync</div><div class="line">#else</div><div class="line">#define aof_fsync fsync</div><div class="line">#endif</div></pre></td></tr></table></figure>
<h5 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h5><p>当aof增长过多的时候会采取aof rewrite来缩小aof文件的大小<br>采取的方式不是去分析aof文件，而是fock一个子进程将内存中的数据dump出一份aof，替换老的aof文件，这当中会忽略已过期的键。如果此时server还在处理命令则将命令也放在rewrite buffer内，当完成aof rewrite后将rewrite buffer中的内容追加到新aof文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">no-appendfsync-on-rewrite  yes</div><div class="line">默认值是 no</div><div class="line">#yes : 在日志重写时，不进行命令追加操作，而只是将其放在缓冲区里，如果子进程和父进程都在写磁盘，可能会造成IO冲突</div></pre></td></tr></table></figure></p>
<p>另外<br>这里还涉及fork子进程，以及内存写时复制等知识</p>
<h5 id="rewrite触发条件"><a href="#rewrite触发条件" class="headerlink" title="rewrite触发条件"></a>rewrite触发条件</h5><ul>
<li>执行命令 bgrewriteaof</li>
<li>自动触发: 满足触发条件时事件循环时会触发<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int aof_no_fsync_on_rewrite;    /* Don&apos;t fsync if a rewrite is in prog. */</div><div class="line">int aof_rewrite_perc;           /* Rewrite AOF if % growth is &gt; M and... */</div><div class="line">off_t aof_rewrite_min_size;     /* the AOF file is at least N bytes. */</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2、rdb"><a href="#2、rdb" class="headerlink" title="2、rdb"></a>2、rdb</h3><p>rdb 文件可以被压缩</p>
<h5 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h5><p> REDIS | RDB-VERSION | SELECT-DB | KEY-VALUE-PAIRS | EOF | CHECK-SUM</p>
<h5 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h5><ul>
<li>执行命令 bgsave</li>
<li>自动触发 经过多少秒且多少个key有改变就进行，可以配置多个<br>我们的线上配置是 save 600 50000，也就是说每600秒 且 至少有50000个key发生变化就执行一次bgsave</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">for (j = 0; j &lt; server.saveparamslen; j++) &#123;</div><div class="line">            struct saveparam *sp = server.saveparams+j;</div><div class="line"></div><div class="line">            /* Save if we reached the given amount of changes,</div><div class="line">             * the given amount of seconds, and if the latest bgsave was</div><div class="line">             * successful or if, in case of an error, at least</div><div class="line">             * REDIS_BGSAVE_RETRY_DELAY seconds already elapsed. */</div><div class="line">            if (server.dirty &gt;= sp-&gt;changes &amp;&amp;</div><div class="line">                server.unixtime-server.lastsave &gt; sp-&gt;seconds &amp;&amp;</div><div class="line">                (server.unixtime-server.lastbgsave_try &gt;</div><div class="line">                 REDIS_BGSAVE_RETRY_DELAY ||</div><div class="line">                 server.lastbgsave_status == REDIS_OK))</div><div class="line">            &#123;</div><div class="line">                redisLog(REDIS_NOTICE,&quot;%d changes in %d seconds. Saving...&quot;,</div><div class="line">                    sp-&gt;changes, (int)sp-&gt;seconds);</div><div class="line">                rdbSaveBackground(server.rdb_filename);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">         &#125;</div></pre></td></tr></table></figure>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="http://doc.redisfans.com" target="_blank" rel="external">http://doc.redisfans.com</a></li>
<li><a href="https://github.com/huangz1990/annotated_redis_sourcel" target="_blank" rel="external">https://github.com/huangz1990/annotated_redis_sourcel</a></li>
<li><a href="!http://redisbook.readthedocs.org/en/latest/">《redis设计与实现》</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/08/redis存储分析/" data-id="cj08aqmb40002brrdff3ehtgx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/26/hello-world/" class="article-date">
  <time datetime="2016-07-26T05:12:04.000Z" itemprop="datePublished">2016-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/26/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/26/hello-world/" data-id="cj08aqmb00001brrdl2mbynsh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/03/13/使用inotify和epoll实现tail命令/">使用inotify和epoll实现tail命令</a>
          </li>
        
          <li>
            <a href="/2016/12/08/redis存储分析/">redis存储分析</a>
          </li>
        
          <li>
            <a href="/2016/07/26/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 龟仙老人<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>